#!/usr/bin/env python3
# -----------------------------------------------------------------------------
# Filename: vulnerability_scan.py
# Author: Rajaram Lakshmanan
# Description: Performs vulnerability scanning on the Edge gateway.
# License: MIT (see LICENSE)
# -----------------------------------------------------------------------------

import os
import subprocess
import re
import logging
import threading
from abc import ABC
from datetime import datetime, timezone

from edge_gateway.base_collector_publisher import BaseCollectorPublisher
from edge_gateway.helper.shell_command import ShellCommand
from event_bus.models.edge_gateway.security.vulnerability_scan_event import VulnerabilityInfo, VulnerabilityScanEvent
from event_bus.models.trigger_event import TriggerEvent
from event_bus.redis_stream_bus.redis_stream_bus import RedisStreamBus
from event_bus.stream_name import StreamName

logger = logging.getLogger("VulnerabilityScan")

class VulnerabilityScan(BaseCollectorPublisher, ABC):
    """
    A utility class for performing and reporting security vulnerability scans.

    This class scans for multiple types of vulnerabilities, including package vulnerabilities,
    security misconfigurations, outdated packages, and exposed network services. It classifies
    findings by severity and provides CVE IDs where applicable. After collection, it publishes
    this registry to a Redis stream for digital twin consumption and security analysis.

    Vulnerability time_series is essential for risk management in healthcare applications,
    identifying and prioritizing security weaknesses that could potentially expose
    patient time_series or compromise health monitoring system integrity.
    """

    def __init__(self, event_bus: RedisStreamBus):
        """
        Initialize the VulnerabilityScan collector.

        Args:
            event_bus (RedisStreamBus): Event bus to publish time_series to.
        """
        super().__init__(event_bus)

        self._event_bus.register_stream(StreamName.EDGE_GW_VULNERABILITY_SCAN.value, VulnerabilityScanEvent)

        # Register for the trigger stream
        self._event_bus.register_stream(StreamName.EDGE_GW_VULNERABILITY_SCAN_TRIGGER.value, TriggerEvent)

        self.vulnerabilities = []
        logger.debug("Successfully initialized Vulnerability Scan")

    def collect(self):
        """Collect vulnerability registry by scanning the system."""
        try:
            logger.info("Starting security vulnerability scan")
            self._information_available = False
            self._collection_in_progress = True

            self._check_package_vulnerabilities()
            self._check_security_misconfigurations()
            self.check_outdated_packages()
            self.check_exposed_services()

            self._information_available = True
            logger.debug(f"Successfully collected {len(self.vulnerabilities)} vulnerabilities")
        except Exception as e:
            logger.exception(f"Failed to complete vulnerability scan: {e}", exc_info=True)
        finally:
            self._collection_in_progress = False

    def publish(self):
        """Publish vulnerability scan results to the event bus."""
        try:
            logger.info("Publishing vulnerability scan results")

            if not self.vulnerabilities:
                logger.warning("No vulnerabilities to publish")
                return

            vulnerabilities = [VulnerabilityInfo(cve_id=vuln["cve_id"],
                                                 component=vuln["component"],
                                                 severity=vuln["severity"],
                                                 description=vuln["description"],
                                                 status=vuln.get("status", "unpatched"))
                               for vuln in self.vulnerabilities]

            scan_date = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
            vulnerability_scan_event = VulnerabilityScanEvent(scan_date=scan_date,
                                                              vulnerabilities=vulnerabilities)
            self._publish_to_stream(StreamName.EDGE_GW_VULNERABILITY_SCAN.value, vulnerability_scan_event)
            logger.info(f"Published vulnerability scan event: {vulnerability_scan_event.event_id}")
        except Exception as e:
            logger.error(f"Failed to publish vulnerability scan event: {e}", exc_info=True)

    def subscribe_to_events(self) -> None:
        """Subscribe to the trigger event for the SpO2 sensor."""
        self._event_bus.subscribe(StreamName.EDGE_GW_VULNERABILITY_SCAN_TRIGGER.value,
                                  "vulnerability_scan_trigger_consumer",
                                  lambda event: self._trigger_scan(event))

    def _trigger_scan(self, scan_trigger_event: TriggerEvent) -> None:
        """
        Trigger a vulnerability scan and publish the result.
        """
        logger.debug(f"Received sensor trigger event: {scan_trigger_event}")

        # Use a separate thread to avoid blocking the Redis callback
        def trigger_thread():
            try:
                if not self.collection_in_progress:
                    logger.info("Triggering Vulnerability Scan...")
                    self.collect_and_publish()
                else:
                    logger.error(f"Another vulnerability scan is in progress.")
            except Exception as e:
                logger.error(f"Error triggering vulnerability scan: {e}")

        # Start the thread
        thread = threading.Thread(target=trigger_thread)
        thread.daemon = True
        thread.start()

    def _check_package_vulnerabilities(self):
        """Check installed packages for known vulnerabilities."""
        try:
            VulnerabilityScan._ensure_package("apt-show-versions")
            logger.debug("Checking installed packages for known vulnerabilities...")

            # First, get the upgrade registry
            apt_output = ShellCommand.execute(["sudo", "apt-get", "upgrade", "-s"])

            # Then filter the results in Python
            security_updates = ""
            if apt_output:
                lines = apt_output.splitlines()
                security_updates = "\n".join(
                    [line for line in lines if line.startswith("Inst") and "security" in line.lower()])

            for line in security_updates.strip().splitlines():
                match = re.search(r"Inst\s+(\S+)\s+\[([^]]+)]\s+\(([^ )]+)", line)
                if match:
                    package, current_version, new_version = match.groups()
                    logger.debug(f"Found vulnerability in package: {package}")

                    cve_ids = "UNKNOWN"
                    try:
                        curl_output = VulnerabilityScan._run_cmd(
                            f"curl -s https://security-tracker.debian.org/tracker/package/{package}")
                        cve_match = re.search(r"CVE-\d{4}-\d{4,}", curl_output)
                        if cve_match:
                            cve_ids = cve_match.group(0)
                    except Exception as e:
                        logger.warning(f"Failed to get CVE ID for {package}: {e}")

                    severity = "medium"
                    if any(package.startswith(critical) for critical in
                           ["openssh", "ssl", "linux-image", "sudo", "pam", "libssl"]):
                        severity = "high"
                    elif any(package.startswith(mid) for mid in ["python", "php", "apache"]):
                        severity = "medium"

                    description = f"Security update available: {package} ({current_version} -> {new_version})"
                    self.vulnerabilities.append({"cve_id": cve_ids,
                                                 "component": package,
                                                 "severity": severity,
                                                 "description": description,
                                                 "status": "unpatched"})
        except Exception as e:
            logger.error(f"Error checking package vulnerabilities: {e}")

    def _check_security_misconfigurations(self):
        """Check for security misconfigurations."""
        try:
            logger.debug("Checking for security misconfigurations...")

            world_writable = VulnerabilityScan._run_cmd("sudo find /etc /bin /usr/bin /usr/local/bin -type f -perm -o+w")
            if world_writable:
                count = len(world_writable.strip().splitlines())
                self.vulnerabilities.append({"cve_id": "MISCONFIGURATION",
                                             "component": "file_permissions",
                                             "severity": "high",
                                             "description": f"Found {count} world-writable files in system directories"})

            if not os.path.isfile("/etc/apt/apt.conf.d/20auto-upgrades"):
                self.vulnerabilities.append({"cve_id": "MISCONFIGURATION",
                                             "component": "system_updates",
                                             "severity": "medium",
                                             "description": "Automatic security updates not configured"})

            if os.path.isfile("/etc/ssh/sshd_config"):
                ssh_config = open("/etc/ssh/sshd_config").read()

                if "PermitRootLogin yes" in ssh_config:
                    self.vulnerabilities.append({"cve_id": "MISCONFIGURATION",
                                                 "component": "ssh_config",
                                                 "severity": "high",
                                                 "description": "SSH configuration allows root login"})

                if "PasswordAuthentication yes" in ssh_config:
                    key_based_auth = any(os.path.isfile(os.path.join(home, ".ssh/authorized_keys"))
                                         for _, _, _, _, _, home, _ in map(lambda l: l.split(":"), open("/etc/passwd"))
                                         if os.path.isdir(home))
                    if key_based_auth:
                        description = "SSH allows password authentication while key authentication is available"
                        severity = "medium"
                    else:
                        description = "SSH using only password authentication, no key-based authentication configured"
                        severity = "low"
                    self.vulnerabilities.append({"cve_id": "MISCONFIGURATION",
                                                 "component": "ssh_config",
                                                 "severity": severity,
                                                 "description": description})

            if os.path.isfile("/etc/sudoers"):
                # Use `sudo` to read the sudoers file
                with subprocess.Popen(['sudo', 'cat', '/etc/sudoers'], stdout=subprocess.PIPE) as proc:
                    sudoers_content = proc.stdout.read().decode()

                if "NOPASSWD" in sudoers_content:
                    self.vulnerabilities.append({"cve_id": "MISCONFIGURATION",
                                                 "component": "sudo_config",
                                                 "severity": "high",
                                                 "description": "Sudo configuration allows execution without password"})
        except Exception as e:
            logger.error(f"Error checking security misconfigurations: {e}")

    def check_outdated_packages(self):
        """Check for outdated packages."""
        try:
            logger.debug("Checking for outdated packages...")
            upgradable_count = int(VulnerabilityScan._run_cmd("sudo apt-get --just-print upgrade | grep -c '^Inst'") or 0)

            if upgradable_count > 0:
                severity = "low"
                if upgradable_count > 50:
                    severity = "high"
                elif upgradable_count > 20:
                    severity = "medium"
                self.vulnerabilities.append({"cve_id": "OUTDATED_PACKAGES",
                                             "component": "package_management",
                                             "severity": severity,
                                             "description": f"System has {upgradable_count} outdated packages"})
        except Exception as e:
            logger.error(f"Error checking outdated packages: {e}")

    def check_exposed_services(self):
        """Check for exposed services on all network interfaces."""
        try:
            logger.debug("Checking for exposed services...")
            listening = VulnerabilityScan._run_cmd("sudo ss -tuln | grep LISTEN")
            exposed = [line for line in listening.strip().splitlines() if "0.0.0.0:" in line or ":::" in line]

            for line in exposed:
                match = re.search(r":(\d+)\s+", line)
                if match:
                    port = int(match.group(1))
                    services = {22: "SSH", 80: "Web", 443: "Web", 21: "FTP", 25: "SMTP",
                                587: "SMTP", 3306: "MySQL", 5432: "PostgreSQL", 27017: "MongoDB"}
                    service = services.get(port, f"Service on port {port}")
                    severity = "high" if port in [22, 21, 25, 3306, 5432, 27017] else "medium"
                    self.vulnerabilities.append({"cve_id": "EXPOSED_SERVICE",
                                                 "component": "network",
                                                 "severity": severity,
                                                 "description": f"{service} exposed on all network "
                                                                f"interfaces (port {port})"})
        except Exception as e:
            logger.error(f"Error checking exposed services: {e}")

    @staticmethod
    def _run_cmd(cmd):
        """
        Run a shell command and return its output.

        Args:
            cmd: The command to run as a list of strings

        Returns:
            The output of the command or an empty string if it fails
        """
        try:
            # Split the command string into a list if it's a string
            command_args = cmd.split() if isinstance(cmd, str) else cmd
            return subprocess.check_output(command_args, stderr=subprocess.DEVNULL, text=True)
        except subprocess.CalledProcessError:
            return ""

    @staticmethod
    def _ensure_package(pkg_name):
        """
        Ensure a package is installed.

        Args:
            pkg_name: The name of the package to install
        """
        try:
            # Using ShellCommand.execute with a proper argument list
            ShellCommand.execute(["sudo", "apt-get", "install", "-y", pkg_name])
        except Exception as e:
            logger.warning(f"Failed to install package {pkg_name}: {e}")